# Storage Engine

### Persistence Mechanisms

Taproot currently uses the built-in C++ hash tables (`unordered_map`) provided in the standard library for O(1) reads/writes of strings as well as Redis-style log storage consisting of `.aof` Append-Only Files and `.db` binary snapshots. 

#### Append-Only Files

Append-Only Files (AOFs) are essentially log files which append the mutable query commands (like `PUT` and `DEL`) that were entered during runtime. At shutdown, the program checks to see if the AOF file exceeds a predefined size threshold (typically 100 megabytes); if it does, the AOF is compacted by writing the in-memory state of the store to a temporary file, which is then renamed to replace the actual AOF. Compaction involves updating the final state of each key-value pair according to what commands mutated them, thus rendering the file smaller. For example, a file containing "PUT foo bar" and "PUT foo buzz" would only contain "PUT foo buzz" after compaction. Compaction will make the file smaller at the expense of some overhead during runtime. However, this overhead comes with the benefit that the files representing the state of the store will potentially be significantly smaller, and when it comes time to replay the files to reinstate the data, the time it takes will also be much faster. Note that operations that set a lot of unique data pairs without modification will not benefit much from compaction, because compaction principally takes advantage of redundant query commands. In situations where a many mutations occur after data ingestion, compaction is very effective at reducing the storage footprint.

#### Binary Snapshots

Snapshots are binary-serialized versions of the compacted state of the keyspace, where all the key-value pairs are stored. In this case, each keyspace is tied to a hash table in memory, and will have its own separate files allocated according to the user-given name of the keyspace. The snapshots are denoted by the `.db` file extensions and are meant to resemble the Redis Database (RDB) files. By default, the snapshots occur at shutdown – the same time the compacted AOF is generated. But there will be options to customize when snapshots as well as compaction occur. Once the state is compacted, it is held in memory for binary serialization. If the compacted state exceeds a predefined threshold, Taproot leverages LZ4 compression via Yann Collett's third-party library to optimally compress the binary – it does not compress anything smaller because the overhead introduced would render the speedup ineffective. LZ4 was designed to be a faster version of the LZ77 compression algorithm and is used in many modern systems. As a result, the binary snapshots can potentially be significantly smaller than plaintext AOFs and can be compressed extremely fast, resulting in little to no overhead. LZ4 was an instance where I thought it prudent to offload compression to a library expertly designed for this purpose: my own implementation would not be even remotely as efficient, and would distract me from my focus on the database system as a whole. Case in point: I originally implemented a naive version of the related LZW compression algorithm. Switching to LZ4 resulted in a [~22x speedup](performance.md).

Compaction can be very effective, but write-heavy workloads may experience diminishing returns. This is why compaction is supplemented by compression during serialization to prevent bloat as long as the file size is large enough.

#### Original Design

Originally, three file types were used: changelogs, AOFs, and binary snapshots. Changelogs were the raw, human-readable, and uncompacted logs that saved all command usage; it was used mostly as a historical record of the database. The AOFs were still used to replay the store on startup to persist data because they were also compacted versions of the changelog. However, they were also timestamped on each save, and only when a change actually occurred so as to not waste time overwriting the same data. The timestamped AOFs enabled backups up to a predefined constant (e.g., 5), past which the oldest one is overwritten. If the latest AOF was deleted or missing, Taproot would defer to the next most recent AOF. If all of the AOFs used to replay the state of the data on startup were missing, the changelog would be used as the replay file; if that changelog was also missing, all data (besides the binary snapshot) would be lost. If instead the changelog was missing at the start, the AOFs would be used to catch the changelog up. Juggling these three file types became needlessly convoluted, and did not seem to take after Redis, which typically only uses AOFs and DB files. I also anticipated more difficulty introducing concurrency into this paradigm. Thus, I decided to eschew my original three-file system in favor of the simpler two-file system. Here is the Redis documentation for further details: [Redis persistence](https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/).

An example of a problem that became a very real issue during development was this: How do I keep the three different files synced? If the program runs and is interacted with by the user as intended, this is not necessarily a cause for concern. But what happens when the latest AOFs are missing and the changelog is up-to-date? The keyspace states of each file would be out of sync because the AOFs would be stale. On startup, the system would read the AOF and have the outdated data. On shutdown, any mutable commands run would be appended to the changelog indiscriminately. At this point, the changelog is corrupted because consensus is not reached. This problem was the primary reason I decided to use two files – it also happens to be closer to the way Redis implements its storage.
 
As of August 2025, there is no longer any timestamping or log rotation: AOF writes basically happen in-place. In the future, I am considering introducing it as an option within a config system.

#### Performance

Please see [Performance](performance.md) for the effects of certain design decisions on storage and speed.

### Data Structures

Taproot uses the built-in hash table included with the C++ standard library to prioritize speed over sorted queries; in the future I plan to implement my own hash tables as an educational exercise, and my own skip list to handle sorted data.